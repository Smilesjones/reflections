1. What happens when you initialize a repository? Why do you need to do it?

Initializing the repository creates a .git file that allows me to run git
commands on the files in the repository.  I can now use commits to save
different versions and utilize version-control on the files.



2. How is the staging area different from the working directory and the repository?
What value do you think it offers?

The repository contains all the files that can be worked on using git and the
working directory are those files in the directory that can be changed.  The
staging area contains those files that have been changed and are waiting to
be committed.

The main value of having a staging area (as far as I can initially tell) is the
ability to commit multiple files under one commit, thus a logical grouping of
the files.  In java I might add a new class to a program and then add an
instanciation of that class in the main method that is in another class.  If I
could only commit one file at a time, I would have to commit the new class file
and then the main method class in seperate commits.  With the staging area, I
can add the two files and commit them together to have a more logical grouping
of the files that were changed.

  

3. How can you use the staging area to make sure you have one commit per logical
change?

If I have multiple files that are involved in a logical change, then the staging
area is useful to make sure all those files have been changed and then I can
commit them all together.



4. What are some situations when branches would be helpful in keeping your history
organized? How would branches help?

If I am working on a big change, such as a new feature that has many different
components, I might want to make a new branch of the program that incrementally
incorporates the new feature.  This keeps the main program intact while I can
develop the nwe feature.  Once it is complete and working how I want it, I can
merge the branches.



5. How do the diagrams help you visualize the branch structure?



6. What is the result of merging two branches together? Why do we represent it in
the diagram the way we do?



7. What are the pros and cons of Git's automatic merging vs. always doing merges
manually?
